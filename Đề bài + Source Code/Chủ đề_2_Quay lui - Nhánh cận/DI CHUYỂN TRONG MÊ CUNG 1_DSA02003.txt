Cho một mê cung bao gồm các khối được biểu diễn như một ma trận nhị phân A[N][N]. 
Một con chuột đi từ ô đầu tiên góc trái (A[0][0]) đến ô cuối cùng góc phải (A[N-1][N-1]) theo nguyên tắc:
	Down (D): Chuột được phép xuống dưới nếu ô dưới nó có giá trị 1.	
	Right (R): Chuột được phép sang phải dưới nếu ô bên phải nó có giá trị 1.
Hãy đưa ra một hành trình của con chuột trên mê cung. Đưa ra -1 nếu chuột không thể đi đến đích.

Input:
	Dòng đầu tiên đưa vào số lượng bộ test T.
	Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: 
		phần thứ nhất đưa vào số N là kích cỡ của mê cung; 
		dòng tiếp theo đưa vào ma trận nhị phân A[N][N].
	T, N, A[i][j] thỏa mãn ràng buộc: 1≤T ≤10; 2≤N≤10; 0≤A[i][j] ≤1.
Output:
	Đưa ra tất cả đường đi của con chuột trong mê cung theo thứ tự từ điển. 
	Đưa ra -1 nếu chuột không đi được đến đích.



Input

2

4

1  0  0  0

1  1  0  1 

0  1  0  0 

1  1  1  1

5

1 0 0 0 0

1 1 1 1 1

1 1 0 0 1

0 1 1 1 1

0 0 0 1 1

Output

DRDDRR

DDRDRRDR DDRDRRRD DRDDRRDR DRDDRRRD DRRRRDDD

 

#include<bits/stdc++.h>

using namespace std;

int arr[20][20];
int n;
bool check = true;
void back_track(int x, int y, string res){
    if(x == n && y == n){
        cout<<res<<" ";
        check = false;
    }

    if(arr[x + 1][y] == 1) back_track(x + 1, y, res + "D");
    if(arr[x][y + 1] == 1) back_track(x, y + 1, res + "R");
}

void solve(){
    cin>>n;
    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= n; j++)
            cin>>arr[i][j];

    if(arr[1][1] == 0 || arr[n][n] == 0) {
        cout<<-1<<endl;
        return;
    }

    back_track(1, 1, "");

    if(check) cout<<-1;
    cout<<endl;
}

int main(){
    int a; cin>>a;
    while(a--){
        solve();
        check = true;
    }
    return 0;
}
 